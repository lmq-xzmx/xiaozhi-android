package info.dourok.voicebot.ui

import android.content.Context
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import info.dourok.voicebot.AudioRecorder
import info.dourok.voicebot.NavigationEvents
import info.dourok.voicebot.OpusDecoder
import info.dourok.voicebot.OpusEncoder
import info.dourok.voicebot.OpusStreamPlayer
import info.dourok.voicebot.data.SettingsRepository
import info.dourok.voicebot.data.model.DeviceInfo
import info.dourok.voicebot.data.model.TransportType
import info.dourok.voicebot.data.AudioConfig
import info.dourok.voicebot.protocol.AbortReason
import info.dourok.voicebot.protocol.AudioState
import info.dourok.voicebot.protocol.ListeningMode
import info.dourok.voicebot.protocol.MqttProtocol
import info.dourok.voicebot.protocol.Protocol
import info.dourok.voicebot.protocol.WebsocketProtocol
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.Locale
import javax.inject.Inject

@HiltViewModel
class ChatViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
    @NavigationEvents private val navigationEvents: MutableSharedFlow<String>,
    private val deviceInfo: DeviceInfo,
    private val settings: SettingsRepository
) : ViewModel() {

    companion object {
        private const val TAG = "ChatViewModel"
    }

    // ÂÆâÂÖ®ÂàùÂßãÂåñÊ†áÂøó
    private var isInitialized = false
    private var initializationError: String? = null

    // Âª∂ËøüÂàùÂßãÂåñprotocol
    private var protocol: Protocol? = null

    val display = Display()
    var encoder: OpusEncoder? = null
    var decoder: OpusDecoder? = null
    var recorder: AudioRecorder? = null
    var player: OpusStreamPlayer? = null
    var aborted: Boolean = false
    var keepListening: Boolean = true
    val deviceStateFlow = MutableStateFlow(DeviceState.IDLE)
    
    // ÂàùÂßãÂåñÈò∂ÊÆµÁä∂ÊÄÅ
    private val _initializationStage = MutableStateFlow(InitializationStage.CHECKING_PREREQUISITES)
    val initializationStage: StateFlow<InitializationStage> = _initializationStage
    
    var deviceState: DeviceState
        get() = deviceStateFlow.value
        set(value) {
            deviceStateFlow.value = value
        }

    init {
        Log.i(TAG, "üöÄ ChatViewModelÂºÄÂßãÂàùÂßãÂåñ")
        try {
            // Âª∂ËøüÂàùÂßãÂåñÔºåÈÅøÂÖçÂú®ÊûÑÈÄ†ÂáΩÊï∞‰∏≠ÊâßË°åÂ§çÊùÇÊìç‰Ωú
            viewModelScope.launch {
                delay(100) // ÁªôUIÊó∂Èó¥ÂÆåÊàêÊ∏≤Êüì
                performSafeInitialization()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ChatViewModelÊûÑÈÄ†ÂáΩÊï∞ÂºÇÂ∏∏: ${e.message}", e)
            initializationError = e.message
            deviceState = DeviceState.FATAL_ERROR
        }
    }

    /**
     * ÂÆâÂÖ®ÁöÑÂàÜÈò∂ÊÆµÂàùÂßãÂåñÊµÅÁ®ã
     * ÊåâÁÖßÁêÜÊÉ≥Â∑•‰ΩúÊµÅÁ®ãÈÄêÊ≠•ÂàùÂßãÂåñÔºåÊØè‰∏™Èò∂ÊÆµÈÉΩÊúâÂÆåÊï¥ÁöÑÈîôËØØÂ§ÑÁêÜ
     */
    private suspend fun performSafeInitialization() {
        try {
            deviceState = DeviceState.STARTING
            
            // Èò∂ÊÆµ1ÔºöÊ£ÄÊü•ÂâçÁΩÆÊù°‰ª∂
            _initializationStage.value = InitializationStage.CHECKING_PREREQUISITES
            if (!checkPrerequisites()) {
                Log.e(TAG, "ÂâçÁΩÆÊù°‰ª∂Ê£ÄÊü•Â§±Ë¥•")
                deviceState = DeviceState.FATAL_ERROR
                return
            }
            
            // Èò∂ÊÆµ2ÔºöÂàùÂßãÂåñÂçèËÆÆ
            _initializationStage.value = InitializationStage.INITIALIZING_PROTOCOL
            if (!initializeProtocolSafely()) {
                Log.e(TAG, "ÂçèËÆÆÂàùÂßãÂåñÂ§±Ë¥•")
                deviceState = DeviceState.FATAL_ERROR
                return
            }
            
            // ‚≠ê ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁ´ãÂç≥ÂêØÂä®Ê∂àÊÅØÂ§ÑÁêÜÊµÅÁ®ã
            Log.i(TAG, "üî• Á´ãÂç≥ÂêØÂä®Ê∂àÊÅØÂ§ÑÁêÜÊµÅÁ®ã...")
            if (!startMessageProcessingSafely()) {
                Log.e(TAG, "Ê∂àÊÅØÂ§ÑÁêÜÂêØÂä®Â§±Ë¥•")
                deviceState = DeviceState.FATAL_ERROR
                return
            }
            
            // Èò∂ÊÆµ3ÔºöÂª∫Á´ãÁΩëÁªúËøûÊé•
            _initializationStage.value = InitializationStage.CONNECTING_NETWORK
            if (!connectNetworkSafely()) {
                Log.e(TAG, "ÁΩëÁªúËøûÊé•Â§±Ë¥•")
                deviceState = DeviceState.FATAL_ERROR
                return
            }
            
            // Èò∂ÊÆµ4ÔºöËÆæÁΩÆÈü≥È¢ëÁ≥ªÁªü
            _initializationStage.value = InitializationStage.SETTING_UP_AUDIO
            if (!setupAudioSafely()) {
                Log.e(TAG, "Èü≥È¢ëÁ≥ªÁªüËÆæÁΩÆÂ§±Ë¥•")
                deviceState = DeviceState.FATAL_ERROR
                return
            }
            
            // Èò∂ÊÆµ5ÔºöÂÆåÊàêÂàùÂßãÂåñÔºàÊ∂àÊÅØÂ§ÑÁêÜÂ∑≤Âú®Èò∂ÊÆµ2ÂêéÂêØÂä®Ôºâ
            _initializationStage.value = InitializationStage.READY
            deviceState = DeviceState.IDLE
            isInitialized = true
            Log.i(TAG, "‚úÖ ChatViewModelÂàùÂßãÂåñÂÆåÊàê")
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ÂÆâÂÖ®ÂàùÂßãÂåñËøáÁ®ãÂºÇÂ∏∏: ${e.message}", e)
            initializationError = e.message
            deviceState = DeviceState.FATAL_ERROR
        }
    }
    
    /**
     * Ê£ÄÊü•ÂâçÁΩÆÊù°‰ª∂
     */
    private fun checkPrerequisites(): Boolean {
        return try {
            Log.d(TAG, "Ê£ÄÊü•ÂâçÁΩÆÊù°‰ª∂...")
            
            // Ê£ÄÊü•Èü≥È¢ëÊùÉÈôê
            if (!checkAudioPermissions()) {
                Log.e(TAG, "Èü≥È¢ëÊùÉÈôêÊ£ÄÊü•Â§±Ë¥•")
                return false
            }
            
            // Ê£ÄÊü•NativeÂ∫ì
            if (!checkNativeLibraries()) {
                Log.e(TAG, "NativeÂ∫ìÊ£ÄÊü•Â§±Ë¥•")
                return false
            }
            
            // Ê£ÄÊü•ÁΩëÁªúÊùÉÈôê
            if (!checkNetworkPermissions()) {
                Log.e(TAG, "ÁΩëÁªúÊùÉÈôêÊ£ÄÊü•Â§±Ë¥•")
                return false
            }
            
            // Ê£ÄÊü•ÈÖçÁΩÆÂÆåÊï¥ÊÄß
            if (!checkConfiguration()) {
                Log.e(TAG, "ÈÖçÁΩÆÂÆåÊï¥ÊÄßÊ£ÄÊü•Â§±Ë¥•")
                return false
            }
            
            true
        } catch (e: Exception) {
            Log.e(TAG, "ÂâçÁΩÆÊù°‰ª∂Ê£ÄÊü•ÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    private fun checkAudioPermissions(): Boolean {
        return try {
            val permission = context.checkSelfPermission(android.Manifest.permission.RECORD_AUDIO)
            val hasPermission = permission == android.content.pm.PackageManager.PERMISSION_GRANTED
            Log.d(TAG, "Èü≥È¢ëÊùÉÈôêÊ£ÄÊü•ÁªìÊûú: $hasPermission")
            hasPermission
        } catch (e: Exception) {
            Log.e(TAG, "Èü≥È¢ëÊùÉÈôêÊ£ÄÊü•ÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    private fun checkNetworkPermissions(): Boolean {
        return try {
            val internetPermission = context.checkSelfPermission(android.Manifest.permission.INTERNET)
            val networkStatePermission = context.checkSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
            
            val hasPermissions = internetPermission == android.content.pm.PackageManager.PERMISSION_GRANTED &&
                    networkStatePermission == android.content.pm.PackageManager.PERMISSION_GRANTED
            
            Log.d(TAG, "ÁΩëÁªúÊùÉÈôêÊ£ÄÊü•ÁªìÊûú: $hasPermissions")
            hasPermissions
        } catch (e: Exception) {
            Log.e(TAG, "ÁΩëÁªúÊùÉÈôêÊ£ÄÊü•ÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    private fun checkNativeLibraries(): Boolean {
        return try {
            // Â∞ùËØïÂä†ËΩΩNativeÂ∫ì
            System.loadLibrary("app")
            Log.d(TAG, "‚úÖ NativeÂ∫ìÂä†ËΩΩÊàêÂäü")
            
            // È™åËØÅÂÖ≥ÈîÆÂäüËÉΩÂèØÁî®ÊÄßÔºàÈÄöËøáË∞ÉÁî®‰∏Ä‰∏™ÁÆÄÂçïÁöÑJNIÂáΩÊï∞Ôºâ
            try {
                // ÊµãËØïOpusÁºñÁ†ÅÂô®ÂàùÂßãÂåñ
                val testResult = testOpusEncoder()
                if (testResult) {
                    Log.d(TAG, "‚úÖ OpusÁºñÁ†ÅÂô®ÂäüËÉΩÈ™åËØÅÊàêÂäü")
                    true
                } else {
                    Log.e(TAG, "‚ùå OpusÁºñÁ†ÅÂô®ÂäüËÉΩÈ™åËØÅÂ§±Ë¥•")
                    false
                }
            } catch (e: UnsatisfiedLinkError) {
                Log.e(TAG, "‚ùå NativeÂáΩÊï∞Ë∞ÉÁî®Â§±Ë¥•: ${e.message}", e)
                false
            }
            
        } catch (e: UnsatisfiedLinkError) {
            Log.e(TAG, "‚ùå NativeÂ∫ìÂä†ËΩΩÂ§±Ë¥•: ${e.message}", e)
            false
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå NativeÂ∫ìÊ£ÄÊü•ÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    /**
     * ÊµãËØïOpusÁºñÁ†ÅÂô®ÊòØÂê¶Ê≠£Â∏∏Â∑•‰Ωú
     */
    private external fun testOpusEncoder(): Boolean
    
    private fun checkConfiguration(): Boolean {
        return try {
            // Ê£ÄÊü•ËÆæÂ§á‰ø°ÊÅØ
            if (deviceInfo.mac_address.isBlank()) {
                Log.e(TAG, "ËÆæÂ§áMACÂú∞ÂùÄ‰∏∫Á©∫")
                return false
            }
            
            // Ê£ÄÊü•‰º†ËæìÁ±ªÂûãÈÖçÁΩÆ
            when (settings.transportType) {
                TransportType.MQTT -> {
                    // MQTTÊ®°Âºè‰∏ãÊ£ÄÊü•ÈÖçÁΩÆ
                    Log.d(TAG, "Ê£ÄÊü•MQTTÈÖçÁΩÆ...")
                }
                TransportType.WebSockets -> {
                    // WebSocketÊ®°Âºè‰∏ãÊ£ÄÊü•ÈÖçÁΩÆ
                    Log.d(TAG, "Ê£ÄÊü•WebSocketÈÖçÁΩÆ...")
                }
                null -> {
                    Log.e(TAG, "‰º†ËæìÁ±ªÂûãÊú™ÈÖçÁΩÆ")
                    return false
                }
            }
            
            Log.d(TAG, "ÈÖçÁΩÆÊ£ÄÊü•ÈÄöËøá")
            true
        } catch (e: Exception) {
            Log.e(TAG, "ÈÖçÁΩÆÊ£ÄÊü•ÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    /**
     * ÂÆâÂÖ®ÁöÑÂçèËÆÆÂàùÂßãÂåñ
     */
    private suspend fun initializeProtocolSafely(): Boolean {
        return try {
            Log.i(TAG, "ÂºÄÂßãÂÆâÂÖ®ÂçèËÆÆÂàùÂßãÂåñÔºå‰º†ËæìÁ±ªÂûã: ${settings.transportType}")
            
            protocol = when (settings.transportType) {
                TransportType.MQTT -> {
                    val mqttConfig = settings.mqttConfig
                    if (mqttConfig == null) {
                        Log.w(TAG, "MQTTÈÖçÁΩÆÊú™ËÆæÁΩÆÔºåÂõûÈÄÄÂà∞WebSocketÊ®°Âºè")
                        createWebSocketProtocolSafely()
                    } else {
                        Log.i(TAG, "ÂàõÂª∫MQTTÂçèËÆÆÔºåendpoint: ${mqttConfig.endpoint}")
                        try {
                            MqttProtocol(context, mqttConfig)
                        } catch (e: Exception) {
                            Log.e(TAG, "MQTTÂçèËÆÆÂàõÂª∫Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞WebSocket: ${e.message}", e)
                            createWebSocketProtocolSafely()
                        }
                    }
                }
                
                TransportType.WebSockets -> {
                    createWebSocketProtocolSafely()
                }
                
                null -> {
                    Log.e(TAG, "‰º†ËæìÁ±ªÂûãÊú™ÈÖçÁΩÆ")
                    null
                }
            }
            
            val success = protocol != null
            Log.i(TAG, "ÂçèËÆÆÂàùÂßãÂåñÁªìÊûú: $success")
            success
            
        } catch (e: Exception) {
            Log.e(TAG, "ÂçèËÆÆÂàùÂßãÂåñÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    private fun createWebSocketProtocolSafely(): Protocol? {
        return try {
            val webSocketUrl = settings.webSocketUrl
            val finalUrl = if (webSocketUrl.isNullOrEmpty()) {
                val defaultUrl = "ws://47.122.144.73:8000/xiaozhi/v1/"
                Log.i(TAG, "‰ΩøÁî®ÈªòËÆ§WebSocket URL: $defaultUrl")
                defaultUrl
            } else {
                Log.i(TAG, "‰ΩøÁî®ÈÖçÁΩÆÁöÑWebSocket URL: $webSocketUrl")
                webSocketUrl
            }
            
            WebsocketProtocol(deviceInfo, finalUrl, "test-token")
        } catch (e: Exception) {
            Log.e(TAG, "WebSocketÂçèËÆÆÂàõÂª∫Â§±Ë¥•: ${e.message}", e)
            null
        }
    }
    
    /**
     * Âª∫Á´ãÁΩëÁªúËøûÊé•
     */
    private suspend fun connectNetworkSafely(): Boolean {
        return try {
            val proto = protocol
            if (proto == null) {
                Log.e(TAG, "ÂçèËÆÆÊú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïÂª∫Á´ãËøûÊé•")
                return false
            }
            
            Log.i(TAG, "üåê ÂêØÂä®ÂçèËÆÆËøûÊé•...")
            proto.start()
            deviceState = DeviceState.CONNECTING
            
            Log.i(TAG, "üîó Â∞ùËØïÊâìÂºÄÈü≥È¢ëÈÄöÈÅì...")
            if (proto.openAudioChannel()) {
                Log.i(TAG, "‚úÖ Èü≥È¢ëÈÄöÈÅìÊâìÂºÄÊàêÂäü")
                true
            } else {
                Log.e(TAG, "‚ùå Èü≥È¢ëÈÄöÈÅìÊâìÂºÄÂ§±Ë¥•")
                false
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ÁΩëÁªúËøûÊé•Âª∫Á´ãÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    /**
     * ÂÆâÂÖ®ÁöÑÈü≥È¢ëÂ§ÑÁêÜËÆæÁΩÆ
     */
    private suspend fun setupAudioSafely(): Boolean {
        return try {
            val proto = protocol
            if (proto == null) {
                Log.e(TAG, "ÂçèËÆÆÊú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïËÆæÁΩÆÈü≥È¢ëÂ§ÑÁêÜ")
                return false
            }
            
            Log.i(TAG, "üéµ ÂºÄÂßãËÆæÁΩÆÈü≥È¢ëÂ§ÑÁêÜ...")
            
            // ËÆæÁΩÆÈü≥È¢ëÊí≠Êîæ
            if (!setupAudioPlayback(proto)) {
                Log.e(TAG, "Èü≥È¢ëÊí≠ÊîæËÆæÁΩÆÂ§±Ë¥•")
                return false
            }
            
            // ËÆæÁΩÆÈü≥È¢ëÂΩïÂà∂
            if (!setupAudioRecording(proto)) {
                Log.e(TAG, "Èü≥È¢ëÂΩïÂà∂ËÆæÁΩÆÂ§±Ë¥•")
                return false
            }
            
            Log.i(TAG, "‚úÖ Èü≥È¢ëÂ§ÑÁêÜËÆæÁΩÆÂÆåÊàê")
            true
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Èü≥È¢ëÂ§ÑÁêÜËÆæÁΩÆÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    private suspend fun setupAudioPlayback(proto: Protocol): Boolean {
        return try {
            withContext(Dispatchers.IO) {
                launch {
                    val sampleRate = 24000
                    val channels = 1
                    val frameSizeMs = 60 // ÂåπÈÖçÊúçÂä°Âô®ÈÖçÁΩÆ
                    
                    player = OpusStreamPlayer(sampleRate, channels, frameSizeMs)
                    decoder = OpusDecoder(sampleRate, channels, frameSizeMs)
                    
                    player?.start(proto.incomingAudioFlow.map { audioData ->
                        try {
                            deviceState = DeviceState.SPEAKING
                            decoder?.decode(audioData) ?: byteArrayOf()
                        } catch (e: Exception) {
                            Log.e(TAG, "Èü≥È¢ëËß£Á†ÅÂºÇÂ∏∏: ${e.message}")
                            byteArrayOf()
                        }
                    })
                    
                    Log.i(TAG, "üîä Èü≥È¢ëÊí≠ÊîæËÆæÁΩÆÊàêÂäü")
                }
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Èü≥È¢ëÊí≠ÊîæËÆæÁΩÆÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    private suspend fun setupAudioRecording(proto: Protocol): Boolean {
        return try {
            delay(1000) // Á≠âÂæÖÊí≠ÊîæËÆæÁΩÆÂÆåÊàê
            
            viewModelScope.launch {
                try {
                    Log.i(TAG, "üé§ ÂºÄÂßãËÆæÁΩÆÈü≥È¢ëÂΩïÂà∂ÂíåÁºñÁ†Å...")
                    Log.i(TAG, "‰ΩøÁî®Áªü‰∏ÄÈü≥È¢ëÈÖçÁΩÆ - ÈááÊ†∑Áéá: ${AudioConfig.SAMPLE_RATE}Hz, ÈÄöÈÅì: ${AudioConfig.CHANNELS}, Â∏ßÈïø: ${AudioConfig.FRAME_DURATION_MS}ms")
                    
                    // ‰ΩøÁî®Áªü‰∏ÄÁöÑÈü≥È¢ëÈÖçÁΩÆÔºåËß£ÂÜ≥Á°¨ÁºñÁ†ÅÈóÆÈ¢ò
                    encoder = OpusEncoder(AudioConfig.SAMPLE_RATE, AudioConfig.CHANNELS, AudioConfig.FRAME_DURATION_MS)
                    recorder = AudioRecorder(AudioConfig.SAMPLE_RATE, AudioConfig.CHANNELS, AudioConfig.FRAME_DURATION_MS)
                    
                    val audioFlow = recorder?.startRecording()
                    if (audioFlow == null) {
                        Log.e(TAG, "‚ùå Èü≥È¢ëÂΩïÂà∂ÂêØÂä®Â§±Ë¥•")
                        showErrorMessage("Èü≥È¢ëÂΩïÂà∂ÂêØÂä®Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•È∫¶ÂÖãÈ£éÊùÉÈôê")
                        return@launch
                    }
                    
                    Log.i(TAG, "‚úÖ Èü≥È¢ëÂΩïÂà∂Âô®ÂàõÂª∫ÊàêÂäü")
                    
                    val opusFlow = audioFlow.map { encoder?.encode(it) }
                    
                    // Ëá™Âä®ÂºÄÂßãSTTÁõëÂê¨
                    Log.i(TAG, "üì¢ ËÆæÂ§áËøõÂÖ•LISTENINGÁä∂ÊÄÅÔºåÂºÄÂßãSTTÁõëÂê¨")
                    deviceState = DeviceState.LISTENING
                    
                    // ÂèëÈÄÅÂºÄÂßãÁõëÂê¨Êåá‰ª§Âà∞ÊúçÂä°Âô®
                    proto.sendStartListening(ListeningMode.AUTO_STOP)
                    
                    var audioFrameCount = 0
                    opusFlow.collect { encodedData ->
                        encodedData?.let { 
                            proto.sendAudio(it)
                            audioFrameCount++
                            
                            // ÊØè100Â∏ßËÆ∞ÂΩï‰∏ÄÊ¨°ÁªüËÆ°ÔºåÂáèÂ∞ëÊó•ÂøóÂô™Èü≥
                            if (audioFrameCount % 100 == 0) {
                                Log.d(TAG, "üé§ Â∑≤ÂèëÈÄÅÈü≥È¢ëÂ∏ß: $audioFrameCount, ÊúÄÊñ∞Â∏ßÂ§ßÂ∞è: ${it.size}Â≠óËäÇ")
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Èü≥È¢ëÂΩïÂà∂ËÆæÁΩÆÂ§±Ë¥•: ${e.message}", e)
                    showErrorMessage("Èü≥È¢ëÂΩïÂà∂ËÆæÁΩÆÂ§±Ë¥•: ${e.message}")
                    deviceState = DeviceState.FATAL_ERROR
                }
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Èü≥È¢ëÂΩïÂà∂ËÆæÁΩÆÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    /**
     * ÂÆâÂÖ®ÂêØÂä®Ê∂àÊÅØÂ§ÑÁêÜÊµÅÁ®ã
     * Â¢ûÂº∫STTÂìçÂ∫îÂ§ÑÁêÜÂíåÈîôËØØËØäÊñ≠
     */
    private suspend fun startMessageProcessingSafely(): Boolean {
        return try {
            val proto = protocol
            if (proto == null) {
                Log.e(TAG, "ÂçèËÆÆÊú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïÂêØÂä®Ê∂àÊÅØÂ§ÑÁêÜ")
                return false
            }
            
            Log.i(TAG, "üöÄ ÂêØÂä®Â¢ûÂº∫ÁâàÊ∂àÊÅØÂ§ÑÁêÜÊµÅÁ®ã...")
            
            // ÂêØÂä®ÁΩëÁªúÈîôËØØÁõëÂê¨
            viewModelScope.launch(Dispatchers.IO) {
                try {
                    proto.networkErrorFlow.collect { error ->
                        Log.e(TAG, "üö® ÁΩëÁªúÈîôËØØ: $error")
                        schedule {
                            showErrorMessage(error)
                            if (deviceState != DeviceState.FATAL_ERROR) {
                                deviceState = DeviceState.IDLE
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "ÁΩëÁªúÈîôËØØÁõëÂê¨ÂºÇÂ∏∏: ${e.message}", e)
                }
            }
            
            // ÂêØÂä®Èü≥È¢ëÈÄöÈÅìÁä∂ÊÄÅÁõëÂê¨
            viewModelScope.launch(Dispatchers.IO) {
                try {
                    proto.audioChannelStateFlow.collect { state ->
                        Log.i(TAG, "üîä Èü≥È¢ëÈÄöÈÅìÁä∂ÊÄÅÂèòÂåñ: $state")
                        when (state) {
                            AudioState.OPENED -> {
                                Log.i(TAG, "‚úÖ Èü≥È¢ëÈÄöÈÅìÂ∑≤ÊâìÂºÄ")
                            }
                            AudioState.CLOSED -> {
                                Log.w(TAG, "‚ö†Ô∏è Èü≥È¢ëÈÄöÈÅìÂ∑≤ÂÖ≥Èó≠")
                                if (deviceState == DeviceState.LISTENING || deviceState == DeviceState.SPEAKING) {
                                    schedule {
                                        deviceState = DeviceState.IDLE
                                    }
                                }
                            }
                            AudioState.ERROR -> {
                                Log.e(TAG, "‚ùå Èü≥È¢ëÈÄöÈÅìÈîôËØØ")
                                schedule {
                                    deviceState = DeviceState.FATAL_ERROR
                                    showErrorMessage("Èü≥È¢ëÈÄöÈÅìÈîôËØØÔºåËØ∑ÈáçÊñ∞Â∞ùËØï")
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Èü≥È¢ëÁä∂ÊÄÅÁõëÂê¨ÂºÇÂ∏∏: ${e.message}", e)
                }
            }
            
            // ÂêØÂä®Ê∂àÊÅØÂ§ÑÁêÜÂçèÁ®ã - Â¢ûÂº∫STTÂ§ÑÁêÜ
            viewModelScope.launch(Dispatchers.IO) {
                try {
                    Log.i(TAG, "üì° ÂºÄÂßãÁõëÂê¨ÊúçÂä°Âô®ÂìçÂ∫îÊ∂àÊÅØ...")
                    
                    var messageCount = 0
                    var sttResponseCount = 0
                    var lastSttTime = 0L
                    
                    proto.incomingJsonFlow.collect { json ->
                        messageCount++
                        Log.i(TAG, "üéØ Êî∂Âà∞ÊúçÂä°Âô®JSONÊ∂àÊÅØ #$messageCount: ${json.toString()}")
                        
                        val type = json.optString("type", "")
                        Log.i(TAG, "üìã Ê∂àÊÅØÁ±ªÂûã: '$type'")
                        
                        when (type) {
                            "tts" -> {
                                val state = json.optString("state")
                                Log.i(TAG, "üîä TTSÊ∂àÊÅØÔºåÁä∂ÊÄÅ: $state")
                                when (state) {
                                    "start" -> {
                                        schedule {
                                            aborted = false
                                            if (deviceState == DeviceState.IDLE || deviceState == DeviceState.LISTENING) {
                                                deviceState = DeviceState.SPEAKING
                                                Log.i(TAG, "üì¢ ÂºÄÂßãTTSÊí≠Êîæ")
                                            }
                                        }
                                    }
                                    "end" -> {
                                        schedule {
                                            Log.i(TAG, "üì¢ TTSÊí≠ÊîæÁªìÊùü")
                                            if (keepListening && !aborted) {
                                                proto.sendStartListening(ListeningMode.AUTO_STOP)
                                                deviceState = DeviceState.LISTENING
                                                Log.i(TAG, "üé§ ÈáçÊñ∞ÂºÄÂßãSTTÁõëÂê¨")
                                            } else {
                                                deviceState = DeviceState.IDLE
                                            }
                                        }
                                    }
                                }
                            }
                            
                            "stt" -> {
                                sttResponseCount++
                                val currentTime = System.currentTimeMillis()
                                val text = json.optString("text")
                                val isFinal = json.optBoolean("is_final", false)
                                
                                Log.i(TAG, "üé§ *** STTÂìçÂ∫î #$sttResponseCount ***: text='$text', is_final=$isFinal")
                                Log.i(TAG, "   STTÂìçÂ∫îÈó¥Èöî: ${if (lastSttTime > 0) currentTime - lastSttTime else 0}ms")
                                lastSttTime = currentTime
                                
                                if (isFinal && text.isNotEmpty()) {
                                    schedule {
                                        Log.i(TAG, "üìù STTÊúÄÁªàÁªìÊûú: $text")
                                        display.setChatMessage("user", text)
                                        deviceState = DeviceState.IDLE
                                    }
                                } else if (text.isNotEmpty()) {
                                    Log.i(TAG, "üìù STT‰∏≠Èó¥ÁªìÊûú: $text")
                                    // ÂèØ‰ª•ÈÄâÊã©ÊòæÁ§∫‰∏≠Èó¥ÁªìÊûú
                                }
                            }
                            
                            "llm" -> {
                                val text = json.optString("text")
                                Log.i(TAG, "ü§ñ *** LLMÂìçÂ∫î ***: $text")
                                if (text.isNotEmpty()) {
                                    schedule {
                                        display.setChatMessage("assistant", text)
                                    }
                                }
                            }
                            
                            "emotion" -> {
                                val emotion = json.optString("emotion")
                                Log.i(TAG, "üòä *** ÊÉÖÊÑüÂìçÂ∫î ***: $emotion")
                                if (emotion.isNotEmpty()) {
                                    schedule {
                                        display.setEmotion(emotion)
                                    }
                                }
                            }
                            
                            "hello" -> {
                                Log.i(TAG, "ü§ù Êî∂Âà∞ÊúçÂä°Âô®HelloÊè°ÊâãÂìçÂ∫î")
                                // Ëß£ÊûêÊúçÂä°Âô®HelloÂìçÂ∫îÔºåÈ™åËØÅÂçèËÆÆÂÖºÂÆπÊÄß
                                val serverVersion = json.optInt("version", -1)
                                val serverFrameDuration = json.optInt("frame_duration", -1)
                                Log.i(TAG, "   ÊúçÂä°Âô®ÁâàÊú¨: $serverVersion, Â∏ßÈïøÂ∫¶: ${serverFrameDuration}ms")
                                
                                if (serverVersion != AudioConfig.PROTOCOL_VERSION) {
                                    Log.w(TAG, "‚ö†Ô∏è ÂçèËÆÆÁâàÊú¨‰∏çÂåπÈÖç: ÂÆ¢Êà∑Á´Ø=${AudioConfig.PROTOCOL_VERSION}, ÊúçÂä°Âô®=$serverVersion")
                                }
                                if (serverFrameDuration != AudioConfig.FRAME_DURATION_MS) {
                                    Log.w(TAG, "‚ö†Ô∏è Â∏ßÈïøÂ∫¶‰∏çÂåπÈÖç: ÂÆ¢Êà∑Á´Ø=${AudioConfig.FRAME_DURATION_MS}ms, ÊúçÂä°Âô®=${serverFrameDuration}ms")
                                }
                            }
                            
                            "error" -> {
                                val errorMsg = json.optString("message", json.optString("error", "Êú™Áü•ÈîôËØØ"))
                                Log.e(TAG, "‚ùå ÊúçÂä°Âô®ËøîÂõûÈîôËØØ: $errorMsg")
                                schedule {
                                    showErrorMessage("ÊúçÂä°Âô®ÈîôËØØ: $errorMsg")
                                }
                            }
                            
                            "stt_fallback" -> {
                                // Â§ÑÁêÜJSONËß£ÊûêÂ§±Ë¥•‰ΩÜÂèØËÉΩÂåÖÂê´STT‰ø°ÊÅØÁöÑÂõûÈÄÄÊ∂àÊÅØ
                                val rawText = json.optString("raw_text", "")
                                Log.w(TAG, "üéØ Â§ÑÁêÜSTTÂõûÈÄÄÊ∂àÊÅØ: $rawText")
                                // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§çÊùÇÁöÑÊñáÊú¨Ëß£ÊûêÈÄªËæë
                            }
                            
                            "" -> {
                                Log.w(TAG, "‚ö†Ô∏è Êî∂Âà∞Êó†Á±ªÂûãÊ∂àÊÅØ: ${json.toString()}")
                                // Êô∫ËÉΩÂ§ÑÁêÜÊó†Á±ªÂûãÊ∂àÊÅØÔºåÂáèÂ∞ëÂÜó‰Ωô
                                val possibleSTTContent = json.optString("text", 
                                                         json.optString("transcript", 
                                                         json.optString("recognition", "")))
                                if (possibleSTTContent.isNotEmpty()) {
                                    Log.i(TAG, "üéØ Áñë‰ººSTTÊó†Á±ªÂûãÂìçÂ∫îÔºåÊñáÊú¨: '$possibleSTTContent'")
                                        schedule {
                                        display.setChatMessage("user", possibleSTTContent)
                                        }
                                } else {
                                    Log.d(TAG, "   Êó†Á±ªÂûãÊ∂àÊÅØÊó†ÊúâÊïàÂÜÖÂÆπÔºåË∑≥Ëøá")
                                }
                            }
                            
                            else -> {
                                Log.d(TAG, "üîÑ ÂÖ∂‰ªñÁ±ªÂûãÊ∂àÊÅØ: $typeÔºåÂÜÖÂÆπ: ${json.toString()}")
                                // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÊñáÊú¨ÂÜÖÂÆπ
                                val textContent = json.optString("text", "")
                                if (textContent.isNotEmpty()) {
                                    Log.i(TAG, "   ÂèëÁé∞ÊñáÊú¨ÂÜÖÂÆπ: '$textContent'")
                                }
                            }
                        }
                        
                        // ÂÆöÊúüËæìÂá∫ÁªüËÆ°‰ø°ÊÅØ
                        if (messageCount % 50 == 0) {
                            Log.i(TAG, "üìä Ê∂àÊÅØÁªüËÆ° - ÊÄªÊ∂àÊÅØ: $messageCount, STTÂìçÂ∫î: $sttResponseCount")
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Ê∂àÊÅØÂ§ÑÁêÜÊµÅÁ®ãÂºÇÂ∏∏: ${e.message}", e)
                    schedule {
                        showErrorMessage("Ê∂àÊÅØÂ§ÑÁêÜÂºÇÂ∏∏: ${e.message}")
                    deviceState = DeviceState.FATAL_ERROR
                    }
                }
            }
            
            Log.i(TAG, "‚úÖ Â¢ûÂº∫ÁâàÊ∂àÊÅØÂ§ÑÁêÜÊµÅÁ®ãÂêØÂä®ÊàêÂäü")
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Ê∂àÊÅØÂ§ÑÁêÜÂêØÂä®ÂºÇÂ∏∏: ${e.message}", e)
            false
        }
    }
    
    /**
     * Â¢ûÂº∫ÁöÑÈîôËØØÊ∂àÊÅØÊòæÁ§∫
     */
    private fun showErrorMessage(message: String) {
        Log.e(TAG, "ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ: $message")
        viewModelScope.launch {
            try {
                navigationEvents.emit("error:$message")
            } catch (e: Exception) {
                Log.e(TAG, "ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØÂ§±Ë¥•: ${e.message}", e)
            }
        }
    }

    fun toggleChatState() {
        viewModelScope.launch {
            when (deviceState) {
                DeviceState.ACTIVATING -> {
                    reboot()
                }

                DeviceState.IDLE -> {
                    if (protocol?.openAudioChannel() == true) {
                        keepListening = true
                        protocol?.sendStartListening(ListeningMode.AUTO_STOP)
                        deviceState = DeviceState.LISTENING
                    } else {
                        deviceState = DeviceState.IDLE
                    }
                }

                DeviceState.SPEAKING -> {
                    abortSpeaking(AbortReason.NONE)
                }

                DeviceState.LISTENING -> {
                    protocol?.closeAudioChannel()
                }

                else -> {
                    Log.e(TAG, "Protocol not initialized or invalid state")
                }
            }
        }
    }

    fun startListening() {
        viewModelScope.launch {
            if (deviceState == DeviceState.ACTIVATING) {
                reboot()
                return@launch
            }

            keepListening = false
            if (deviceState == DeviceState.IDLE) {
                val proto = protocol
                if (proto != null && !proto.isAudioChannelOpened()) {
                    deviceState = DeviceState.CONNECTING
                    if (!proto.openAudioChannel()) {
                        deviceState = DeviceState.IDLE
                        return@launch
                    }
                }
                proto?.sendStartListening(ListeningMode.MANUAL)
                deviceState = DeviceState.LISTENING
            } else if (deviceState == DeviceState.SPEAKING) {
                abortSpeaking(AbortReason.NONE)
                protocol?.sendStartListening(ListeningMode.MANUAL)
                delay(120) // Wait for the speaker to empty the buffer
                deviceState = DeviceState.LISTENING
            }
        }
    }

    private fun reboot() {
        // ÂÆûÁé∞ÈáçÂêØÈÄªËæë
        Log.i(TAG, "Rebooting device...")
        viewModelScope.launch {
            try {
                // ÂÖ≥Èó≠ÂΩìÂâçËøûÊé•
                protocol?.closeAudioChannel()
                protocol?.dispose()
                
                // ÈáçÁΩÆËÆæÂ§áÁä∂ÊÄÅ
                deviceState = DeviceState.STARTING
                
                // ÈáçÊñ∞ÊâßË°åÂÆâÂÖ®ÂàùÂßãÂåñ
                performSafeInitialization()
            } catch (e: Exception) {
                Log.e(TAG, "Failed to reboot", e)
                deviceState = DeviceState.FATAL_ERROR
                showErrorMessage("ÈáçÂêØÂ§±Ë¥•Ôºö${e.message}")
            }
        }
    }

    fun abortSpeaking(reason: AbortReason) {
        Log.i(TAG, "Abort speaking")
        aborted = true
        viewModelScope.launch {
            protocol?.sendAbortSpeaking(reason)
        }
    }
    
    private fun schedule(task: suspend () -> Unit) {
        viewModelScope.launch {
            task()
        }
    }

    fun stopListening() {
        viewModelScope.launch {
            if (deviceState == DeviceState.LISTENING) {
                protocol?.sendStopListening()
                deviceState = DeviceState.IDLE
            }
        }
    }

    override fun onCleared() {
        try {
            protocol?.dispose()
            encoder?.release()
            decoder?.release()
            player?.stop()
            recorder?.stopRecording()
        } catch (e: Exception) {
            Log.e(TAG, "Ê∏ÖÁêÜËµÑÊ∫êÊó∂ÂèëÁîüÂºÇÂ∏∏: ${e.message}", e)
        }
        super.onCleared()
    }
}

/**
 * ÂàùÂßãÂåñÈò∂ÊÆµÊûö‰∏æ
 */
enum class InitializationStage {
    CHECKING_PREREQUISITES,    // Ê£ÄÊü•ÂâçÁΩÆÊù°‰ª∂
    INITIALIZING_PROTOCOL,     // ÂàùÂßãÂåñÂçèËÆÆ
    CONNECTING_NETWORK,        // ËøûÊé•ÁΩëÁªú
    SETTING_UP_AUDIO,         // ËÆæÁΩÆÈü≥È¢ë
    STARTING_MESSAGE_PROCESSING, // ÂêØÂä®Ê∂àÊÅØÂ§ÑÁêÜ
    READY                     // ÂáÜÂ§áÂ∞±Áª™
}

enum class DeviceState {
    UNKNOWN,
    STARTING,
    WIFI_CONFIGURING,
    IDLE,
    CONNECTING,
    LISTENING,
    SPEAKING,
    UPGRADING,
    ACTIVATING,
    FATAL_ERROR
}

class Display {
    val chatFlow = MutableStateFlow<List<Message>>(listOf())
    val emotionFlow = MutableStateFlow<String>("neutral")
    fun setChatMessage(sender: String, message: String) {
        chatFlow.value = chatFlow.value + Message(sender, message)
    }

    fun setEmotion(emotion: String) {
        emotionFlow.value = emotion
    }
}

val df = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

data class Message(
    val sender: String = "",
    val message: String = "",
    val nowInString: String = df.format(System.currentTimeMillis())
)
